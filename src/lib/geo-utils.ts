/**
 * Geographic Utilities
 * Coordinate conversion and district detection for Tokyo 3D experience
 * 
 * NOTE: The math part was generated by AI because idk what kind of wizardry magic was needed.
 */

import * as THREE from "three";
import { TOKYO_DISTRICTS, DEFAULT_DISTRICT_PROMPT, EARTH_RADIUS, type District } from "@/config/tokyo-config";

// WGS84 ellipsoid parameters
const WGS84_A = 6378137.0; // Semi-major axis (equatorial radius)
const WGS84_B = 6356752.314245; // Semi-minor axis (polar radius)
const WGS84_E2 = 1 - (WGS84_B * WGS84_B) / (WGS84_A * WGS84_A); // First eccentricity squared

/**
 * Convert geodetic coordinates (lat, lng, altitude) to ECEF (Earth-Centered, Earth-Fixed)
 * @param lat Latitude in degrees
 * @param lng Longitude in degrees  
 * @param alt Altitude in meters above WGS84 ellipsoid
 * @returns THREE.Vector3 in ECEF coordinates (meters)
 */
export function latLngAltToECEF(lat: number, lng: number, alt: number = 0): THREE.Vector3 {
  const latRad = THREE.MathUtils.degToRad(lat);
  const lngRad = THREE.MathUtils.degToRad(lng);

  // Calculate the radius of curvature in the prime vertical
  const sinLat = Math.sin(latRad);
  const cosLat = Math.cos(latRad);
  const N = WGS84_A / Math.sqrt(1 - WGS84_E2 * sinLat * sinLat);

  // ECEF coordinates
  const x = (N + alt) * cosLat * Math.cos(lngRad);
  const y = (N + alt) * cosLat * Math.sin(lngRad);
  const z = (N * (1 - WGS84_E2) + alt) * sinLat;

  return new THREE.Vector3(x, y, z);
}

/**
 * Convert ECEF coordinates to geodetic (lat, lng, altitude)
 * Uses iterative method for accuracy
 * @param ecef THREE.Vector3 in ECEF coordinates (meters)
 * @returns Object with lat, lng (degrees) and alt (meters)
 */
export function ecefToLatLngAlt(ecef: THREE.Vector3): { lat: number; lng: number; alt: number } {
  const x = ecef.x;
  const y = ecef.y;
  const z = ecef.z;

  const lng = THREE.MathUtils.radToDeg(Math.atan2(y, x));

  const p = Math.sqrt(x * x + y * y);
  let lat = Math.atan2(z, p * (1 - WGS84_E2)); // initial estimate
  let alt = 0;

  for (let i = 0; i < 10; i++) {
    const sinLat = Math.sin(lat);
    const N = WGS84_A / Math.sqrt(1 - WGS84_E2 * sinLat * sinLat);
    alt = p / Math.cos(lat) - N;
    lat = Math.atan2(z, p * (1 - WGS84_E2 * N / (N + alt)));
  }

  return {
    lat: THREE.MathUtils.radToDeg(lat),
    lng,
    alt,
  };
}

/**
 * Convert geodetic to local East-North-Up (ENU) coordinates relative to an origin
 * Useful for local-scale operations where we want a flat coordinate system
 * @param lat Latitude in degrees
 * @param lng Longitude in degrees
 * @param alt Altitude in meters
 * @param originLat Origin latitude in degrees
 * @param originLng Origin longitude in degrees
 * @param originAlt Origin altitude in meters
 * @returns THREE.Vector3 in ENU coordinates (meters) with Three.js Y-up remap
 */
export function latLngAltToENU(
  lat: number,
  lng: number,
  alt: number,
  originLat: number,
  originLng: number,
  originAlt: number = 0
): THREE.Vector3 {
  // convert both points to ECEF
  const pointECEF = latLngAltToECEF(lat, lng, alt);
  const originECEF = latLngAltToECEF(originLat, originLng, originAlt);

  const diff = pointECEF.clone().sub(originECEF);

  // rotation matrix from ECEF to ENU
  const latRad = THREE.MathUtils.degToRad(originLat);
  const lngRad = THREE.MathUtils.degToRad(originLng);

  const sinLat = Math.sin(latRad);
  const cosLat = Math.cos(latRad);
  const sinLng = Math.sin(lngRad);
  const cosLng = Math.cos(lngRad);

  // ENU coordinates (X=east, Y=north, Z=up)
  const east = -sinLng * diff.x + cosLng * diff.y;
  const north = -sinLat * cosLng * diff.x - sinLat * sinLng * diff.y + cosLat * diff.z;
  const up = cosLat * cosLng * diff.x + cosLat * sinLng * diff.y + sinLat * diff.z;

  // Remap to Three.js world (Y-up): X=east, Y=up, Z=-north
  // Note: Z is negated to match the enuToYUp matrix in GoogleTilesScene.tsx
  // which maps ECEF tiles such that +Z points south (geographic north is -Z)
  return new THREE.Vector3(east, up, -north);
}

/**
 * Convert ENU coordinates back to geodetic
 * @param enu THREE.Vector3 in ENU coordinates (meters), Y-up remap (X=east, Y=up, Z=-north)
 * @param originLat Origin latitude in degrees
 * @param originLng Origin longitude in degrees
 * @param originAlt Origin altitude in meters
 * @returns Object with lat, lng (degrees) and alt (meters)
 */
export function enuToLatLngAlt(
  enu: THREE.Vector3,
  originLat: number,
  originLng: number,
  originAlt: number = 0
): { lat: number; lng: number; alt: number } {
  const east = enu.x;
  const up = enu.y;
  const north = -enu.z; // Y-up remap: Z=-north, so north = -Z

  const latRad = THREE.MathUtils.degToRad(originLat);
  const lngRad = THREE.MathUtils.degToRad(originLng);

  const sinLat = Math.sin(latRad);
  const cosLat = Math.cos(latRad);
  const sinLng = Math.sin(lngRad);
  const cosLng = Math.cos(lngRad);

  // inverse rotation from ENU to ECEF difference
  const dx = -sinLng * east - sinLat * cosLng * north + cosLat * cosLng * up;
  const dy = cosLng * east - sinLat * sinLng * north + cosLat * sinLng * up;
  const dz = cosLat * north + sinLat * up;

  const originECEF = latLngAltToECEF(originLat, originLng, originAlt);
  const pointECEF = new THREE.Vector3(
    originECEF.x + dx,
    originECEF.y + dy,
    originECEF.z + dz
  );

  return ecefToLatLngAlt(pointECEF);
}

/**
 * Calculate great-circle distance between two points using Haversine formula
 * @param lat1 First point latitude in degrees
 * @param lng1 First point longitude in degrees
 * @param lat2 Second point latitude in degrees
 * @param lng2 Second point longitude in degrees
 * @returns Distance in meters
 */
export function haversineDistance(
  lat1: number,
  lng1: number,
  lat2: number,
  lng2: number
): number {
  const lat1Rad = THREE.MathUtils.degToRad(lat1);
  const lat2Rad = THREE.MathUtils.degToRad(lat2);
  const dLat = THREE.MathUtils.degToRad(lat2 - lat1);
  const dLng = THREE.MathUtils.degToRad(lng2 - lng1);

  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(lat1Rad) * Math.cos(lat2Rad) * Math.sin(dLng / 2) * Math.sin(dLng / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  return EARTH_RADIUS * c;
}

/**
 * Get the district that contains a given position (radius-based)
 * Returns the district whose center is closest AND within its radius
 * @param lat Latitude in degrees
 * @param lng Longitude in degrees
 * @returns District object or null if outside all districts
 */
export function getDistrictAtPosition(lat: number, lng: number): District | null {
  let closestDistrict: District | null = null;
  let closestDistance = Infinity;

  for (const district of TOKYO_DISTRICTS) {
    const distance = haversineDistance(lat, lng, district.center.lat, district.center.lng);
    
    if (distance <= district.radius && distance < closestDistance) {
      closestDistance = distance;
      closestDistrict = district;
    }
  }

  return closestDistrict;
}

/**
 * Calculate weights for all districts based on distance from a position
 * Returns normalized weights that sum to 1
 * @param lat Latitude in degrees
 * @param lng Longitude in degrees
 * @param falloffDistance Distance in meters at which weight reaches ~0.1
 * @returns Array of { district, weight, distance } sorted by weight descending
 */
export function calculateDistrictWeights(
  lat: number,
  lng: number,
  falloffDistance: number = 2000
): Array<{ district: District; weight: number; distance: number }> {
  const results = TOKYO_DISTRICTS.map((district) => {
    const distance = haversineDistance(lat, lng, district.center.lat, district.center.lng);
    const rawWeight = Math.exp(-distance / falloffDistance);
    return { district, weight: rawWeight, distance };
  });

  const totalWeight = results.reduce((sum, r) => sum + r.weight, 0);
  if (totalWeight > 0) {
    results.forEach((r) => {
      r.weight = r.weight / totalWeight;
    });
  }

  results.sort((a, b) => b.weight - a.weight);

  return results;
}

/**
 * Get Lyria prompts with weights based on camera position
 * @param lat Latitude in degrees
 * @param lng Longitude in degrees
 * @param maxPrompts Maximum number of prompts to include (top N by weight)
 * @param minWeight Minimum weight threshold to include a prompt
 * @returns Array of { text, weight } for Lyria API
 */
export function getWeightedPromptsForPosition(
  lat: number,
  lng: number,
  maxPrompts: number = 4,
  minWeight: number = 0.05
): Array<{ text: string; weight: number }> {
  const districtWeights = calculateDistrictWeights(lat, lng);
  const currentDistrict = getDistrictAtPosition(lat, lng);

  if (currentDistrict) {
    const idx = districtWeights.findIndex((d) => d.district.id === currentDistrict.id);
    if (idx !== -1) {
      districtWeights[idx].weight = Math.min(1, districtWeights[idx].weight * 1.5);
      const total = districtWeights.reduce((sum, d) => sum + d.weight, 0);
      districtWeights.forEach((d) => {
        d.weight = d.weight / total;
      });
    }
  }

  const prompts = districtWeights
    .filter((d) => d.weight >= minWeight)
    .slice(0, maxPrompts)
    .map((d) => ({
      text: d.district.prompt,
      weight: d.weight,
    }));
  if (prompts.length === 0) {
    prompts.push({ text: DEFAULT_DISTRICT_PROMPT, weight: 1.0 });
  }

  return prompts;
}

/**
 * Convert Three.js world position to lat/lng/alt
 * This assumes the 3d-tiles-renderer places tiles in ECEF coordinates
 * @param worldPos THREE.Vector3 world position
 * @returns Object with lat, lng (degrees) and alt (meters)
 */
export function worldToLatLngAlt(worldPos: THREE.Vector3): { lat: number; lng: number; alt: number } {
  return ecefToLatLngAlt(worldPos);
}

/**
 * Convert lat/lng/alt to Three.js world position
 * @param lat Latitude in degrees
 * @param lng Longitude in degrees
 * @param alt Altitude in meters
 * @returns THREE.Vector3 world position
 */
export function latLngAltToWorld(lat: number, lng: number, alt: number): THREE.Vector3 {
  return latLngAltToECEF(lat, lng, alt);
}

const _tempVec3 = new THREE.Vector3();
const _tempLatLng = { lat: 0, lng: 0, alt: 0 };

/**
 * Get district info for camera position (optimized, no allocations)
 * @param cameraWorldPos Camera world position
 * @returns Current district or null
 */
export function getDistrictForCamera(cameraWorldPos: THREE.Vector3): District | null {
  const geo = ecefToLatLngAlt(cameraWorldPos);
  return getDistrictAtPosition(geo.lat, geo.lng);
}

/**
 * Get weighted prompts for camera position (optimized)
 * @param cameraWorldPos Camera world position
 * @returns Weighted prompts for Lyria
 */
export function getWeightedPromptsForCamera(
  cameraWorldPos: THREE.Vector3
): Array<{ text: string; weight: number }> {
  const geo = ecefToLatLngAlt(cameraWorldPos);
  return getWeightedPromptsForPosition(geo.lat, geo.lng);
}

